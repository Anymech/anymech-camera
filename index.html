<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Anymech Live Capture</title>
 <style>
  :root{
    --bg: #eaf3ff;           /* âœ… light blue background */
    --card: #ffffff;
    --border: #e6e6e6;
    --shadow: rgba(0,0,0,0.10);
    --btn-border: #cfd9e6;   /* âœ… light border */
    --btn-top: #ffffff;
    --btn-bottom: #eef3fb;
    --btn-shadow: #c7d4e6;   /* âœ… 3D base shadow */
  }

  body{
    font-family:system-ui,Arial;
    margin:16px;
    max-width:900px;
    background: var(--bg);
  }

  .appFrame{
    border:1px solid var(--border);
    border-radius:22px;
    padding:18px;
    box-shadow:0 14px 40px var(--shadow);
    background: var(--card);
  }

  .brandTitle{
    font-size:22px;
    font-weight:900;
    color:#0b5ed7;
    letter-spacing:0.6px;
    margin:0 0 10px 0;
    text-align:center;
  }

  /* âœ… FULL SCREEN CAMERA PREVIEW */
  .camWrap{
    width: 100vw;
    height: 100vh;
    margin: 0;
    position: fixed;
    inset: 0;
    padding-top: 0;
    background: #000;
    border-radius: 0;
    overflow: hidden;
    z-index: 9990;
    display: none; /* only show when camera is ON */
  }

  .camWrap video{
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .card{
    border:1px solid #ddd;
    border-radius:14px;
    padding:14px;
    margin:12px 0;
    background:#fff;
  }

  .status{
    background:#f6f6f6;
    padding:12px;
    border-radius:10px;
    margin-top:10px;
    white-space:pre-wrap;
  }

  .kv{
    display:grid;
    grid-template-columns:180px 1fr;
    gap:10px;
  }
  .kv div{
    padding:8px 0;
    border-bottom:1px dashed #eee;
  }
  .label{font-weight:700}
  .kv div:nth-child(2n){font-weight:800}

  video{
    width:100%;
    aspect-ratio:1/1;
    object-fit:cover;
    background:#000;
    border-radius:12px;
  }

  canvas{display:none}
  .ok{color:#0a7a0a;font-weight:800}

  .guideLine{
    position:absolute;
    left:0; right:0;
    height:2px;
    background:rgba(255,0,0,0.85);
    top:50%;
    pointer-events:none;
  }
  .guideLabel{
    position:absolute;
    left:10px;
    top:calc(50% - 22px);
    background:rgba(0,0,0,0.55);
    color:#fff;
    font-size:12px;
    padding:4px 8px;
    border-radius:8px;
    pointer-events:none;
  }

  /* âœ… 3D BUTTONS (light border + 3D base) */
  .btn{
    width:100%;
    padding:22px;
    border-radius:16px;
    font-size:22px;
    font-weight:900;
    border:1px solid var(--btn-border);
    cursor:pointer;
    background:linear-gradient(var(--btn-top), var(--btn-bottom));
    box-shadow:
      0 10px 0 var(--btn-shadow),
      0 18px 28px rgba(0,0,0,0.12);
    transition:transform 0.08s ease, box-shadow 0.08s ease;
    user-select:none;
    -webkit-tap-highlight-color:transparent;
  }
  .btn:active{
    transform:translateY(6px);
    box-shadow:
      0 4px 0 var(--btn-shadow),
      0 10px 18px rgba(0,0,0,0.12);
  }

  /* âœ… button fixed bottom-center while camera full screen */
  .btnFixed{
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 22px;
    z-index: 9992;
    width: min(92vw, 420px);
    display: none; /* show only when camera is ON */
  }

  .hlRed{background:#ffcccc;border-radius:10px;padding:6px 10px;display:inline-block}
  .hlGreen{background:#ccffcc;border-radius:10px;padding:6px 10px;display:inline-block}

  /* âœ… overlay for "LOGGED COMPLETED" */
  .overlayDone{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.18);
    z-index:9999;
  }
  .overlayCard{
    background:#fff;
    border-radius:20px;
    padding:22px 18px;
    box-shadow:0 18px 50px rgba(0,0,0,0.20);
    text-align:center;
    width:min(320px, 88vw);
  }
  .overlayTick{
    font-size:64px;
    line-height:1;
    color:#0a7a0a;
    font-weight:900;
    margin-bottom:10px;
  }
  .overlayText{
    font-size:18px;
    font-weight:900;
    color:#0a7a0a;
    letter-spacing:0.4px;
  }

  /* âœ… Titles */
  .appTitle{
    text-align:center;
    font-size:38px;
    font-weight:900;
    color:#0b4fd6;
    letter-spacing:1.2px;
    margin:6px 0 18px 0;
  }

  /* âœ… Desktop button sizing for bottom controls */
  #btnCapture,
  #btnSubmit,
  #btnReset{
    display:block;
    margin:32px auto 12px auto;
    width:min(94%, 460px);
    padding:32px;
    font-size:28px;
    font-weight:900;
    border-radius:22px;
  }
  #btnReset{
    margin:12px auto 12px auto;
  }

  /* âœ… Small phones */
  @media (max-width: 520px){
    body{margin:10px;max-width:100%}
    .appFrame{padding:12px;border-radius:18px}
    .card{margin:10px 0;padding:12px}
    .kv{grid-template-columns:140px 1fr}
    .btn{padding:24px;font-size:22px;border-radius:18px}
    .brandTitle{font-size:22px}
  }

  /* âœ… Mobile enhancement (single block, no nesting, no duplicates) */
  @media (max-width: 768px){
    body{
      margin:8px;
      font-size:20px;
    }

    .appFrame{
      padding:20px;
      border-radius:26px;
    }

    h2{
      font-size:26px;
      text-align:center;
    }

    .card{
      padding:18px;
    }

    .kv{
      grid-template-columns: 140px 1fr;
      gap:14px;
    }

    .kv div{
      font-size:26px;        /* âœ… big readable on mobile only */
      padding:16px 0;
    }

    .label{
      font-size:24px;
      font-weight:800;
    }

    video{
      border-radius:16px;
    }

    .btn{
      font-size:22px;
      padding:26px;
      border-radius:18px;
    }

    .status{
      font-size:16px;
      padding:16px;
    }

    .appTitle{
      font-size:42px;
    }

    #memberId,
    #memberName,
    #itemName,
    #outW,
    #inW,
    #readyW,
    #stage{
      font-size:18px;
      font-weight:700;
    }

    /* âœ… Bottom buttons (thumb friendly) */
    #btnCapture,
    #btnSubmit,
    #btnReset{
      width:96%;
      padding:36px;
      font-size:30px;
      border-radius:24px;
    }
  }
</style>
</head>

<body>
  <div class="appFrame">
    <h1 class="appTitle">ANYMECH PRODUCTS</h1>

    <div class="card">
      <!-- âœ… Full screen camera layer -->
      <div class="camWrap" id="camWrap">
        <video id="video" autoplay playsinline></video>
        <div class="guideLine"></div>
        <div class="guideLabel">Top: Card | Bottom: Scale</div>
      </div>

      <canvas id="canvas"></canvas>

      <!-- âœ… full-screen fixed button -->
      <div class="btnFixed" id="btnFixedWrap">
        <button class="btn" id="btnCaptureFixed">CAPTURE</button>
      </div>

      <div class="status" id="status">Press CAPTURE to start live camera.</div>
    </div>

    <div class="card">
      <div class="kv">
        <div class="label">NEW M.NO</div><div id="memberId">-</div>
        <div class="label">MEMBER NAME</div><div id="memberName">-</div>
        <div class="label">ITEM NAME</div><div id="itemName">-</div>
        <div class="label">CAPTURED WEIGHT (PREVIEW)</div><div id="capW">-</div>

        <div class="label">OUT WEIGHT</div><div id="outW">-</div>
        <div class="label">IN WEIGHT</div><div id="inW">-</div>
        <div class="label">READY WEIGHT</div><div id="readyW">-</div>

        <div class="label">SHORT MATERIAL</div><div id="shortMat">-</div>

        <div class="label">STATUS</div><div id="stage">-</div>
      </div>
    </div>

    <!-- âœ… buttons -->
    <button class="btn" id="btnCapture">CAPTURE</button>
    <button class="btn" id="btnSubmit" style="display:none;">SUBMIT</button>
    <button class="btn" id="btnReset" style="display:none;">RESET</button>
    <button class="btn" id="btnSaveOffline" style="display:none;">SAVE OFFLINE</button>

    <script>
      window.onerror = function (msg, src, line, col, err) {
        const s = "JS ERROR: " + msg + "\n" + (src||"") + ":" + line + ":" + col;
        try { document.getElementById("status").textContent = s; } catch(e) {}
        return false;
      };
    </script>

    <script>
      function _ms_(t0){ return Math.round((performance.now() - t0)); }

      let uiState = "idle";
      let stream = null;
      let pendingCapture = null;
      let isSubmitting = false;

      const OFFLINE_DB = "anymech_offline_db";
      const OFFLINE_STORE = "queue";

      // âœ… Device ID
      function getDeviceId(){
        try{
          let id = localStorage.getItem("ANYMECH_DEVICE_ID");
          if (!id){
            id = "DEV-" + Date.now() + "-" + Math.random().toString(16).slice(2);
            localStorage.setItem("ANYMECH_DEVICE_ID", id);
          }
          return id;
        }catch(e){
          return "DEV-UNKNOWN";
        }
      }
      const DEVICE_ID = getDeviceId();

      function idbOpen(){
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(OFFLINE_DB, 1);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains(OFFLINE_STORE)) {
              db.createObjectStore(OFFLINE_STORE, { keyPath: "id" });
            }
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      // âœ… offlineEnqueue exists (required by enqueueCapture)
      async function offlineEnqueue(item){
        const db = await idbOpen();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(OFFLINE_STORE, "readwrite");
          tx.objectStore(OFFLINE_STORE).put(item);
          tx.oncomplete = () => { db.close(); resolve(true); };
          tx.onerror = () => { db.close(); reject(tx.error); };
        });
      }

      // âœ… Consistent queue item format
      async function enqueueCapture(dataUrl, reason){
        const item = {
          id: "Q-" + Date.now() + "-" + Math.random().toString(16).slice(2),
          createdAt: new Date().toISOString(),
          deviceId: DEVICE_ID,
          page: (location && location.href) ? location.href : "",
          status: "QUEUED",
          reason: reason || "",
          payload: {
            imageDataUrl: dataUrl,
            attempts: 0,       // âœ… ADDED: retry counter for OCR fail
            lastError: ""      // âœ… ADDED: last OCR fail reason
          }
        };
        await offlineEnqueue(item);
        return item;
      }

      async function offlineList(){
        const db = await idbOpen();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(OFFLINE_STORE, "readonly");
          const req = tx.objectStore(OFFLINE_STORE).getAll();
          req.onsuccess = () => { const out = req.result || []; db.close(); resolve(out); };
          req.onerror = () => { db.close(); reject(req.error); };
        });
      }

      async function offlineRemove(id){
        const db = await idbOpen();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(OFFLINE_STORE, "readwrite");
          tx.objectStore(OFFLINE_STORE).delete(id);
          tx.oncomplete = () => { db.close(); resolve(true); };
          tx.onerror = () => { db.close(); reject(tx.error); };
        });
      }

      function isOnline(){
        return navigator.onLine === true;
      }

      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const camWrap = document.getElementById("camWrap");
      const btnFixedWrap = document.getElementById("btnFixedWrap");
      const btnCaptureFixed = document.getElementById("btnCaptureFixed");

      const btnSubmit = document.getElementById("btnSubmit");
      const btnReset  = document.getElementById("btnReset");
      const btnSaveOffline = document.getElementById("btnSaveOffline");

      function setStatus(t){ document.getElementById("status").textContent = t; }
      function setBtn(t){ document.getElementById("btnCapture").textContent = t; btnCaptureFixed.textContent = t; }
      function setText(id, t){ document.getElementById(id).textContent = (t ?? "-"); }

      function setStageText(t, completed){
        const el = document.getElementById("stage");
        el.textContent = t ?? "-";
        el.className = completed ? "ok" : "";
      }

      function setShortMaterial(v){
        const el = document.getElementById("shortMat");
        el.className = "";
        if (v === null || v === undefined || v === "" || Number.isNaN(v)){
          el.textContent = "-";
          return;
        }
        const n = Number(v);
        el.textContent = n.toFixed(3);
        if (n < -0.200) el.className = "hlRed";
        else if (n > 0.200) el.className = "hlGreen";
      }

      function tickSound(){
        try{
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "square";
          o.frequency.value = 1200;
          g.gain.value = 0.06;
          o.connect(g); g.connect(ctx.destination);
          o.start();
          setTimeout(()=>{ o.stop(); ctx.close(); }, 90);
        }catch(e){}
      }

      function showLoggedOverlay(){
        const el = document.getElementById("overlayDone");
        if (!el) return;
        el.style.display = "flex";
        setTimeout(()=>{ el.style.display = "none"; }, 1000);
      }

      function resetDisplay(){
        setText("memberId","-");
        setText("memberName","-");
        setText("itemName","-");
        setText("outW","-");
        setText("inW","-");
        setText("readyW","-");
        setShortMaterial(null);
        setStageText("-", false);
        setText("capW","-");
      }

      // ===============================
      // SERVER CALL (FETCH)  âœ… FIXED: NO preflight (no headers)
      // ===============================
      const APPS_SCRIPT_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbwJr73l_9BJfiRAEpIz-x90zhOX78ny4kH53X_RifEqFN7WFcgnnAUpwbeMisMVvtFQcA/exec";

      async function callServer(fnName, args){
        let payload = {};

        if (fnName === "visionExtract") {
          payload = { action: "visionExtract", imageDataUrl: args[0] };
        } else if (fnName === "captureFromOcr") {
          payload = {
            action: "captureFromOcr",
            memberId: args[0],
            itemName: args[1],
            weight: args[2],
            imageDataUrl: args[3]
          };
        } else if (fnName === "postFailTasks") {
          payload = {
            action: "postFailTasks",
            imageDataUrl: args[0],
            failMessage: args[1],
            rawText: args[2]
          };
        } else if (fnName === "queueUpsert") {
          payload = { action: "queueUpsert", item: args[0] };
        } else if (fnName === "queueRemove") {
          payload = { action: "queueRemove", id: args[0], deviceId: args[1] };
        } else if (fnName === "failedOcr") {
          payload = { action: "failedOcr", id: args[0], deviceId: args[1], page: args[2], reason: args[3], imageDataUrl: args[4] };
        } else {
          payload = { action: "unknown" };
        }

        const ctrl = new AbortController();
        const to = setTimeout(() => ctrl.abort(), 25000);

        let res, text;
        try{
          res = await fetch(APPS_SCRIPT_WEBAPP_URL, {
            method: "POST",
            body: JSON.stringify(payload),
            signal: ctrl.signal
          });
          text = await res.text();
        } finally {
          clearTimeout(to);
        }

        if (!res || !res.ok){
          throw new Error("HTTP " + (res ? res.status : "0") + " " + (res ? res.statusText : "") + "\n\n" + (text ? text.slice(0, 600) : ""));
        }

        try{
          return JSON.parse(text);
        }catch(e){
          throw new Error("JSON parse failed. Server returned:\n\n" + (text ? text.slice(0, 600) : ""));
        }
      }

      // âœ… Silent background call (no UI interruptions)
      function callServerNoWait(fnName, args){
        callServer(fnName, args).catch(err=>{
          console.log("Background fail:", err && err.message ? err.message : String(err));
        });
      }

      // =========================
      // button sequencing helpers
      // =========================
      function showCaptureButtons(){
        document.getElementById("btnCapture").style.display = (camWrap.style.display === "block") ? "none" : "block";
        btnFixedWrap.style.display = (camWrap.style.display === "block") ? "block" : "none";
        btnSubmit.style.display = "none";
        btnReset.style.display = "none";
        btnSaveOffline.style.display = "none";
      }

      function showSaveOfflineOnly(){
        if (isOnline()){
          btnSaveOffline.style.display = "none";
          return;
        }

        btnFixedWrap.style.display = "none";
        document.getElementById("btnCapture").style.display = "none";
        btnSubmit.style.display = "none";
        btnReset.style.display = "block";
        btnSaveOffline.style.display = "block";
      }

      function showCameraUI(on){
        camWrap.style.display = on ? "block" : "none";
        btnFixedWrap.style.display = on ? "block" : "none";
        document.getElementById("btnCapture").style.display = on ? "none" : "block";

        if (uiState === "await_submit") {
          btnFixedWrap.style.display = "none";
          document.getElementById("btnCapture").style.display = "none";
          btnSubmit.style.display = "block";
          btnReset.style.display = "block";
        } else {
          btnSubmit.style.display = "none";
          btnReset.style.display = "none";
        }
      }

      window.startLiveCamera = async function startLiveCamera(){
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          throw new Error("Camera API not available in this browser/webview.");
        }
        if (!window.isSecureContext){
          throw new Error("Camera blocked: page is not HTTPS (secure). Open using https:// (or localhost).");
        }

        try { video.muted = true; } catch(e) {}

        try{
          if (navigator.permissions && navigator.permissions.query){
            const st = await navigator.permissions.query({ name: "camera" });
            if (st && st.state === "denied"){
              throw new Error("Camera permission is DENIED in browser settings. Allow camera for this site and reload.");
            }
          }
        }catch(e){}

        const preferred = {
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            aspectRatio: { ideal: 16/9 }
          },
          audio: false
        };

        try{
          stream = await navigator.mediaDevices.getUserMedia(preferred);
        }catch(e1){
          try{
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: { ideal: "environment" },
                aspectRatio: { ideal: 16/9 }
              },
              audio: false
            });
          }catch(e2){
            stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          }
        }

        video.srcObject = stream;

        await new Promise(r => {
          if (video.videoWidth && video.videoHeight) return r();
          video.onloadedmetadata = () => r();
        });

        await video.play();
        await new Promise(r => requestAnimationFrame(r));
        await new Promise(r => requestAnimationFrame(r));

        showCameraUI(true);
      }

      window.stopLiveCamera = function stopLiveCamera(){
        try{
          if (stream){
            stream.getTracks().forEach(t => t.stop());
            stream = null;
          }
        }catch(e){}
        video.srcObject = null;
        showCameraUI(false);
      }

      // âœ… UPDATED: crop 20% top + 20% bottom, smaller max width, more compression
      // (Camera full-screen UI remains unchanged)
      function captureDataUrlFull(){
        const vw = video.videoWidth || 1920;
        const vh = video.videoHeight || 1080;

        // âœ… remove 20% top and 20% bottom => keep middle 60%
        const sx = 0;
        const sw = vw;
        const sy = Math.round(vh * 0.20);
        const sh = Math.round(vh * 0.60);

        // âœ… reduce output size for faster OCR/upload
        const maxW = 960;

        const isPortraitFrame = vh > vw;

        const baseW = sw;
        const baseH = sh;

        const scale = Math.min(1, maxW / baseW);
        const outW = Math.round(baseW * scale);
        const outH = Math.round(baseH * scale);

        const ctx = canvas.getContext("2d", { willReadFrequently:true });
        ctx.save();

        if (isPortraitFrame){
          // rotate to landscape like your original code (no UI change)
          canvas.width = outH;
          canvas.height = outW;

          ctx.translate(canvas.width, 0);
          ctx.rotate(Math.PI / 2);

          // draw cropped region into rotated canvas
          ctx.drawImage(video, sx, sy, sw, sh, 0, 0, outW, outH);
        } else {
          canvas.width = outW;
          canvas.height = outH;

          ctx.drawImage(video, sx, sy, sw, sh, 0, 0, outW, outH);
        }

        ctx.restore();

        // âœ… more compression for speed
        return canvas.toDataURL("image/jpeg", 0.60);
      }

      window.resetClick = async function resetClick(){
        pendingCapture = null;
        btnSubmit.textContent = "SUBMIT";

        resetDisplay();

        setBtn("CAPTURE FRAME");
        setStatus("RESET âœ…\nStarting camera again...");
        try{
          await startLiveCamera();
          uiState = "camera_on";
          setStatus("Camera ON âœ…\nPress CAPTURE FRAME to capture image first, then OCR (Submit will be shown after OCR).");
          showCaptureButtons();
        }catch(err){
          uiState = "idle";
          setBtn("CAPTURE");
          setStatus("RESET âœ…\nCamera failed: " + (err && err.name ? (err.name + " - " + (err.message || "")) : String(err)));
          showCaptureButtons();
        }
      }

      // SAVE OFFLINE (kept)
      window.saveOfflineClick = async function saveOfflineClick(){
        if (!pendingCapture){
          setStatus("Nothing to save. Please CAPTURE first.");
          return;
        }

        await enqueueCapture(pendingCapture.dataUrl, "MANUAL_SAVE_OFFLINE");

        setStatus("ðŸ“´ Saved OFFLINE âœ…\nWill auto sync when internet returns.");
        pendingCapture = null;
        uiState = "idle";
        setBtn("CAPTURE");
        showCaptureButtons();
      };

      window.submitClick = async function submitClick(){
        // âœ… ensure lock never stays ON accidentally
        if (uiState !== "await_submit" || !pendingCapture){
          setStatus("No captured data pending. Please CAPTURE first.");
          uiState = "idle";
          pendingCapture = null;
          setBtn("CAPTURE");
          showCaptureButtons();
          isSubmitting = false;
          return;
        }

        const tSub0 = performance.now();
        setStatus("Submitting...");
        btnSubmit.textContent = "SUBMITTING...";
        isSubmitting = true;

        try{
          // OFFLINE -> queue only image
          if (!isOnline()) {
            await enqueueCapture(pendingCapture.dataUrl, "SUBMIT_OFFLINE");
            setStatus("ðŸ“´ No internet.\nSaved offline.\nWill auto sync when online.");
            btnSubmit.textContent = "SUBMIT";
            uiState = "idle";
            setBtn("CAPTURE");
            showCaptureButtons();
            pendingCapture = null;
            return;
          }

          let resp;
          try{
            resp = await callServer("captureFromOcr", [
              pendingCapture.memberId,
              pendingCapture.itemName,
              pendingCapture.weight,
              pendingCapture.dataUrl
            ]);
          }catch(err){
            await enqueueCapture(pendingCapture.dataUrl, "SUBMIT_NETWORK_ERROR");
            setStatus("âš ï¸ Network error.\nSaved offline.\nWill auto sync.");
            btnSubmit.textContent = "SUBMIT";
            uiState = "idle";
            setBtn("CAPTURE");
            showCaptureButtons();
            pendingCapture = null;
            return;
          }

          const msSub = _ms_(tSub0);

          if (!resp || !resp.ok){
            setStatus("ERROR: " + (resp && resp.message ? resp.message : "Unknown submit error"));
            btnSubmit.textContent = "SUBMIT";
            return;
          }

          const d = (resp && resp.data) ? resp.data : {};

          const outW = (d.outWeight !== undefined && d.outWeight !== null && String(d.outWeight).trim() !== "") ? Number(d.outWeight) : null;
          const inW  = (d.inWeight  !== undefined && d.inWeight  !== null && String(d.inWeight).trim()  !== "") ? Number(d.inWeight)  : null;
          const rdW  = (d.readyWeight !== undefined && d.readyWeight !== null && String(d.readyWeight).trim() !== "") ? Number(d.readyWeight) : null;

          setText("outW",   (outW !== null && !Number.isNaN(outW)) ? String(outW) : "-");
          setText("inW",    (inW  !== null && !Number.isNaN(inW))  ? String(inW)  : "-");
          setText("readyW", (rdW  !== null && !Number.isNaN(rdW))  ? String(rdW)  : "-");

          if (resp.stage === "OUT" || resp.stage === "IN" || resp.stage === "READY") tickSound();

          if (outW !== null && inW !== null && !Number.isNaN(outW) && !Number.isNaN(inW)) setShortMaterial(inW - outW);
          else setShortMaterial(null);

          setText("memberId",   d.memberId || pendingCapture.memberId || "-");
          setText("memberName", d.memberName || pendingCapture.ocrMemberName || "-");
          setText("itemName",   d.itemName || pendingCapture.itemName || "-");

          setText("capW","-");

          let st = d.statusText || resp.stage || "-";
          const completed = !!d.completed;

          if (resp.stage === "OUT") {
            st = "OUT âœ…";
            showLoggedOverlay();
          } else if (resp.stage === "READY" || completed === true) {
            st = "COMPLETED âœ…";
            showLoggedOverlay();
          } else if (resp.stage === "IN") {
            st = "IN âœ…";
          }

          setStageText(st, completed || resp.stage === "READY");

          pendingCapture = null;

          setStatus(
            "SUCCESS âœ… " + resp.message + " (" + st + ")" +
            "\n\nTIMING:\nSubmit call: " + msSub + " ms"
          );

          if (resp.stage === "IN") {
            uiState = "idle";
            btnSubmit.textContent = "SUBMIT";
            setBtn("CAPTURE READY");
            setStatus("IN saved âœ…\nNow capture READY WEIGHT (click CAPTURE READY).");
            try{
              await startLiveCamera();
              uiState = "camera_on";
              showCaptureButtons();
            }catch(err){
              uiState = "idle";
              setBtn("CAPTURE");
              showCaptureButtons();
              setStatus("IN saved âœ…\nCamera failed for READY: " + (err && err.message ? err.message : String(err)));
            }
            return;
          }

          uiState = "idle";
          btnSubmit.textContent = "SUBMIT";
          setBtn("CAPTURE");
          showCaptureButtons();
        } finally {
          // âœ… always release submit lock (no matter what)
          isSubmitting = false;
        }
      }

      window.captureClick = async function captureClick(){
        if (uiState === "idle"){
          pendingCapture = null;
          btnSubmit.textContent = "SUBMIT";
          btnSubmit.style.display = "none";
          btnReset.style.display = "none";

          resetDisplay();
          setBtn("CAPTURE FRAME");
          setStatus("Starting live camera...");
          try{
            await startLiveCamera();
            uiState = "camera_on";
            setStatus("Camera ON âœ…\nPress CAPTURE FRAME to capture image first, then OCR (Submit will be shown after OCR).");
            showCaptureButtons();
          }catch(err){
            uiState = "idle";
            setBtn("CAPTURE");
            setStatus("Camera failed: " + (err && err.name ? (err.name + " - " + (err.message || "")) : String(err)));
            showCaptureButtons();
          }
          return;
        }

        if (uiState === "camera_on"){
          setBtn("PROCESSING...");
          setStatus("Capturing image (freezing frame)...");
          const dataUrl = captureDataUrlFull();

          setStatus("Captured âœ…\nImage size: " + Math.round(dataUrl.length/1024) + " KB\nRunning OCR...");

          stopLiveCamera();

          // âœ… OFFLINE: queue instantly and return to normal capture (online flow untouched)
          if (!isOnline()){
            await enqueueCapture(dataUrl, "AUTO_OFFLINE_CAPTURE");
            pendingCapture = null;
            uiState = "idle";
            setBtn("CAPTURE");
            showCaptureButtons();
            setStatus("ðŸ“´ Offline: captured & queued âœ…");
            return;
          }

          setStatus("Image captured âœ…\nRunning OCR...");
          const tOcr0 = performance.now();
          let r;
          try{
            r = await callServer("visionExtract", [dataUrl]);
          }catch(err){
            const msOcr = _ms_(tOcr0);

            setStatus(
              "ERROR: OCR call failed\n" +
              "Name: " + (err && err.name ? err.name : "-") + "\n" +
              "Message: " + (err && err.message ? err.message : String(err)) + "\n" +
              "Online: " + (navigator.onLine ? "YES" : "NO") + "\n" +
              "Page: " + (location && location.href ? location.href : "-") + "\n" +
              "\nTIMING:\nOCR call: " + msOcr + " ms"
            );

            setBtn("CAPTURE");
            uiState = "idle";
            showCaptureButtons();
            return;
          }

          const msOcr = _ms_(tOcr0);

          if (!r || !r.ok){
            pendingCapture = {
              memberId: "",
              itemName: "",
              weight: null,
              dataUrl: dataUrl,
              ocrMemberName: "",
              ocrItemName: ""
            };

            uiState = "await_save_offline";
            setStatus(
              "OCR failed.\n" +
              "You can SAVE OFFLINE now and it will auto-sync when online.\n\n" +
              (r && r.message ? ("Reason: " + r.message) : "")
            );

            showSaveOfflineOnly();
            return;
          }

          setText("memberId", r.memberId || "-");
          setText("memberName", r.memberName || "-");
          setText("itemName", r.itemName || "-");
          setText("capW", (r.weight !== undefined && r.weight !== null) ? String(r.weight) : "-");

          pendingCapture = {
            memberId: r.memberId,
            itemName: r.itemName,
            weight: r.weight,
            dataUrl: dataUrl,
            ocrMemberName: r.memberName || "",
            ocrItemName: r.itemName || ""
          };

          uiState = "await_submit";

          setStatus(
            "OCR DONE âœ…\n" +
            "Press SUBMIT to upload & sync to Google Sheet.\n\n" +
            "TIMING:\nOCR call: " + msOcr + " ms"
          );

          btnSubmit.style.display = "block";
          btnReset.style.display = "block";
          btnSaveOffline.style.display = "none";
          btnFixedWrap.style.display = "none";
          document.getElementById("btnCapture").style.display = "none";
          return;
        }
      }

      // âœ… Background sync: silent + never interrupts online
      let isSyncingOffline = false;

      // âœ… UPDATED: offline queue OCR retry 3 times; after 3 fails -> move to FAILED OCR sheet + clear local cache
      async function syncOfflineQueue(){
        if (!isOnline()) return;
        if (isSyncingOffline) return;
        if (isSubmitting) return; // âœ… submit lock
        if (uiState === "camera_on" || uiState === "await_submit") return; // âœ… don't interrupt active camera/submit UI

        const items = await offlineList();
        if (!items || items.length === 0) return;

        isSyncingOffline = true;

        try{
          console.log("SYNC: offline queue count =", items.length);

          // âœ… process ONLY 1 item per cycle (fast + no interruption)
          const item = items[0];

          const img = item?.payload?.imageDataUrl;
          if (!img){
            await offlineRemove(item.id);
            return;
          }

          // Ensure fields exist (for older cached items)
          if (!item.payload) item.payload = { imageDataUrl: img };
          if (typeof item.payload.attempts !== "number") item.payload.attempts = 0;
          if (typeof item.payload.lastError !== "string") item.payload.lastError = "";

          // optional: show in UPLOAD_QUEUE sheet (if server supports)
          try{
            item.status = "PROCESSING";
            callServerNoWait("queueUpsert", [item]);
          }catch(e){}

          // âœ… OCR retry loop (3 tries in this sync cycle)
          let r = null;
          let lastMsg = "";
          const MAX_TRIES = 3;

          for (let i = 0; i < MAX_TRIES; i++){
            try{
              r = await callServer("visionExtract", [img]);
              if (r && r.ok) break;
              lastMsg = (r && r.message) ? r.message : "OCR_FAILED";
            }catch(err){
              lastMsg = (err && err.message) ? err.message : "OCR_CALL_ERROR";
            }
          }

          // If OCR still fails after retries
          if (!r || !r.ok){
            item.payload.attempts += 1;
            item.payload.lastError = lastMsg || "OCR_FAILED";

            // âœ… If attempts reached 3 -> move to FAILED OCR sheet + clear local queue
            if (item.payload.attempts >= 3){
              try{
                callServerNoWait("failedOcr", [
                  item.id,
                  item.deviceId || DEVICE_ID,
                  item.page || (location && location.href ? location.href : ""),
                  "OCR_FAILED_AFTER_3_TRIES: " + item.payload.lastError,
                  img
                ]);
                item.status = "FAILED_OCR";
                item.reason = item.payload.lastError;
                callServerNoWait("queueUpsert", [item]);
                callServerNoWait("queueRemove", [item.id, item.deviceId || DEVICE_ID]);
              }catch(e){}

              // âœ… CLEAR CACHE: remove from IndexedDB to avoid duplicates/new entry conflicts
              await offlineRemove(item.id);
              console.log("SYNC: moved to FAILED OCR + removed locally", item.id);
              return;
            }

            // âœ… Not yet 3 -> keep item for later retry, save updated attempts back to IndexedDB
            try{
              item.status = "RETRY_OCR";
              item.reason = item.payload.lastError;
              callServerNoWait("queueUpsert", [item]);
            }catch(e){}

            await offlineEnqueue(item);
            console.log("SYNC: OCR failed, will retry later", item.id, "attempt:", item.payload.attempts);
            return;
          }

          // âœ… OCR success -> upload
          const resp = await callServer("captureFromOcr", [
            r.memberId || "",
            r.itemName || "",
            (r.weight !== undefined ? r.weight : null),
            img
          ]);

          if (!resp || !resp.ok){
            try{
              item.status = "FAILED_UPLOAD";
              item.reason = (resp && resp.message ? resp.message : "UPLOAD_FAILED");
              callServerNoWait("queueUpsert", [item]);
            }catch(e){}
            console.log("SYNC: upload failed for", item.id);
            return; // keep for retry later
          }

          try{
            item.status = "UPLOADED";
            item.reason = "";
            callServerNoWait("queueUpsert", [item]);
            callServerNoWait("queueRemove", [item.id, item.deviceId || DEVICE_ID]);
          }catch(e){}

          await offlineRemove(item.id);
          console.log("SYNC: uploaded & removed", item.id);

        } finally {
          isSyncingOffline = false;
        }
      }

      window.addEventListener("online", syncOfflineQueue);
      setInterval(syncOfflineQueue, 30000);

      // init
      resetDisplay();
      setBtn("CAPTURE");
      setStatus("Press CAPTURE to start live camera.");

      document.getElementById("btnCapture").addEventListener("click", captureClick);
      btnCaptureFixed.addEventListener("click", captureClick);

      btnSubmit.addEventListener("click", submitClick);
      btnReset.addEventListener("click", resetClick);
      btnSaveOffline.style.display = "none";
      btnSaveOffline.addEventListener("click", saveOfflineClick);
      showCaptureButtons();

      // try sync on load (safe, silent)
      syncOfflineQueue();
    </script>
  </div>

  <div class="overlayDone" id="overlayDone">
    <div class="overlayCard">
      <div class="overlayTick">âœ…</div>
      <div class="overlayText">LOGGED COMPLETED</div>
    </div>
  </div>
</body>
</html>
