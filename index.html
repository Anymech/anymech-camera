<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Anymech Live Capture</title>
  <style>
    body{font-family:system-ui,Arial;margin:16px;max-width:900px}

    .appFrame{
      border:1px solid #e6e6e6;
      border-radius:22px;
      padding:18px;
      box-shadow:0 14px 40px rgba(0,0,0,0.10);
      background:#fff;
    }

    .brandTitle{
      font-size:22px;
      font-weight:900;
      color:#0b5ed7;
      letter-spacing:0.6px;
      margin:0 0 10px 0;
      text-align:center;
    }

    /* âœ… FULL SCREEN CAMERA PREVIEW */
    .camWrap{
      width: 100vw;
      height: 100vh;
      margin: 0;
      position: fixed;
      inset: 0;
      padding-top: 0;
      background: #000;
      border-radius: 0;
      overflow: hidden;
      z-index: 9990;
      display: none; /* only show when camera is ON */
    }

    .camWrap video{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .card{border:1px solid #ddd;border-radius:14px;padding:14px;margin:12px 0;background:#fff}
    .status{background:#f6f6f6;padding:12px;border-radius:10px;margin-top:10px;white-space:pre-wrap}

    .kv{display:grid;grid-template-columns:180px 1fr;gap:10px}
    .kv div{padding:8px 0;border-bottom:1px dashed #eee}
    .label{font-weight:700}
    .kv div:nth-child(2n){font-weight:800}

    video{width:100%;aspect-ratio:1/1;object-fit:cover;background:#000;border-radius:12px}
    canvas{display:none}
    .ok{color:#0a7a0a;font-weight:800}

    .guideLine{
      position:absolute;
      left:0; right:0;
      height:2px;
      background:rgba(255,0,0,0.85);
      top:50%;
      pointer-events:none;
    }
    .guideLabel{
      position:absolute;
      left:10px;
      top:calc(50% - 22px);
      background:rgba(0,0,0,0.55);
      color:#fff;
      font-size:12px;
      padding:4px 8px;
      border-radius:8px;
      pointer-events:none;
    }

    /* âœ… CAPTURE BUTTON ON TOP OF FULL SCREEN CAMERA */
    .btn{
      width:100%;
      padding:22px;
      border-radius:16px;
      font-size:22px;
      font-weight:900;
      border:1px solid #b9b9b9;
      cursor:pointer;
      background:linear-gradient(#ffffff,#f1f1f1);
      box-shadow:
        0 10px 0 #d0d0d0,
        0 18px 28px rgba(0,0,0,0.12);
      transition:transform 0.08s ease, box-shadow 0.08s ease;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .btn:active{
      transform:translateY(6px);
      box-shadow:
        0 4px 0 #d0d0d0,
        0 10px 18px rgba(0,0,0,0.12);
    }

    /* âœ… button fixed bottom-center while camera full screen */
.btnFixed{
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 22px;
  z-index: 9992;
  width: min(92vw, 420px);
  display: none; /* show only when camera is ON */
}


    .hlRed{background:#ffcccc;border-radius:10px;padding:6px 10px;display:inline-block}
    .hlGreen{background:#ccffcc;border-radius:10px;padding:6px 10px;display:inline-block}

    /* âœ… ADDED: mobile view (no logic change) */
    @media (max-width: 520px){
      body{margin:10px;max-width:100%}
      .appFrame{padding:12px;border-radius:18px}
      .card{margin:10px 0;padding:12px}
      .kv{grid-template-columns:140px 1fr}
      .btn{padding:24px;font-size:22px;border-radius:18px}
      .brandTitle{font-size:22px}
    }

    /* âœ… ADDED: overlay for "LOGGED COMPLETED" */
    .overlayDone{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.18);
      z-index:9999;
    }
    .overlayCard{
      background:#fff;
      border-radius:20px;
      padding:22px 18px;
      box-shadow:0 18px 50px rgba(0,0,0,0.20);
      text-align:center;
      width:min(320px, 88vw);
    }
    .overlayTick{
      font-size:64px;
      line-height:1;
      color:#0a7a0a;
      font-weight:900;
      margin-bottom:10px;
    }
    .overlayText{
      font-size:18px;
      font-weight:900;
      color:#0a7a0a;
      letter-spacing:0.4px;
    }

    /* âœ… MOBILE VIEW ENHANCEMENT â€“ DO NOT AFFECT DESKTOP */
    @media (max-width: 768px) {

      body{
        margin:8px;
        font-size:20px;
      }

      .appFrame{
        padding:20px;
        border-radius:26px;
      }

      h2{
        font-size:26px;
        text-align:center;
      }

      .card{
        padding:18px;
      }

      .kv{
        grid-template-columns: 140px 1fr;
        gap:14px;
      }

      .kv div{
        font-size:18px;
        padding:12px 0;
      }

      .label{
        font-size:18px;
        font-weight:800;
      }

      video{
        border-radius:16px;
      }

      .btn{
        font-size:22px;
        padding:26px;
        border-radius:18px;
      }

      .status{
        font-size:16px;
        padding:16px;
      }

    }
    .appTitle{
      text-align:center;
      font-size:38px;
      font-weight:900;
      color:#0b4fd6;
      letter-spacing:1.2px;
      margin:6px 0 18px 0;
    }
    /* ðŸ”¥ Bigger capture details for mobile */
    .kv div{
      font-size:24px;
      padding:16px 0;
    }

    .label{
      font-size:24px;
      font-weight:900;
    }

    /* Values on right side */
    #memberId,
    #memberName,
    #itemName,
    #outW,
    #inW,
    #readyW,
    #stage{
      font-size:24px;
      font-weight:800;
    }
    @media (max-width: 768px){
      .appTitle{
        font-size:42px;
      }

      .kv div{
        font-size:26px;
      }

      .label{
        font-size:26px;
      }

      #memberId,
      #memberName,
      #itemName,
      #outW,
      #inW,
      #readyW,
      #stage{
        font-size:26px;
      }

    /* âœ… Centered bottom CAPTURE button (layout only) */
#btnCapture{
  display: block;
  margin: 28px auto 6px auto; /* center + push to bottom of layout */
  width: min(92%, 420px);
  padding: 30px;
  font-size: 26px;
  font-weight: 900;
  border-radius: 20px;
}

/* ðŸ“± Bigger & thumb-friendly on mobile */
@media (max-width: 768px){
  #btnCapture{
    width: 94%;
    padding: 34px;
    font-size: 28px;
    border-radius: 22px;
  }
}
/* âœ… CAPTURE button at very bottom after all details */
#btnCapture{
  display: block;
  margin: 32px auto 12px auto; /* pushes it BELOW details */
  width: min(94%, 460px);
  padding: 32px;
  font-size: 28px;
  font-weight: 900;
  border-radius: 22px;
}

/* ðŸ“± Mobile emphasis */
@media (max-width: 768px){
  #btnCapture{
    width: 96%;
    padding: 36px;
    font-size: 30px;
    border-radius: 24px;
  }
}

    }

    /* âœ… ADDED: match SUBMIT bottom styling (no logic change) */
    #btnSubmit{
      display: block;
      margin: 32px auto 12px auto;
      width: min(94%, 460px);
      padding: 32px;
      font-size: 28px;
      font-weight: 900;
      border-radius: 22px;
    }
    @media (max-width: 768px){
      #btnSubmit{
        width: 96%;
        padding: 36px;
        font-size: 30px;
        border-radius: 24px;
      }
    }

    /* âœ… ADDED: match RESET bottom styling (no logic change) */
    #btnReset{
      display: block;
      margin: 12px auto 12px auto;
      width: min(94%, 460px);
      padding: 32px;
      font-size: 28px;
      font-weight: 900;
      border-radius: 22px;
    }
    @media (max-width: 768px){
      #btnReset{
        width: 96%;
        padding: 36px;
        font-size: 30px;
        border-radius: 24px;
      }
    }
  </style>
</head>

<body>
  <div class="appFrame">
    <h1 class="appTitle">ANYMECH PRODUCTS</h1>

    <div class="card">
      <!-- âœ… Full screen camera layer -->
      <div class="camWrap" id="camWrap">
        <video id="video" autoplay playsinline></video>
        <div class="guideLine"></div>
        <div class="guideLabel">Top: Card | Bottom: Scale</div>
      </div>

      <canvas id="canvas"></canvas>

      <!-- âœ… full-screen fixed button (same id? NO â€“ keep original unchanged) -->
      <div class="btnFixed" id="btnFixedWrap">
        <button class="btn" id="btnCaptureFixed">CAPTURE</button>
      </div>

      <div class="status" id="status">Press CAPTURE to start live camera.</div>
    </div>

    <div class="card">
      <div class="kv">
        <div class="label">NEW M.NO</div><div id="memberId">-</div>
        <div class="label">MEMBER NAME</div><div id="memberName">-</div>
        <div class="label">ITEM NAME</div><div id="itemName">-</div>
        <div class="label">CAPTURED WEIGHT (PREVIEW)</div><div id="capW">-</div>

        <div class="label">OUT WEIGHT</div><div id="outW">-</div>
        <div class="label">IN WEIGHT</div><div id="inW">-</div>
        <div class="label">READY WEIGHT</div><div id="readyW">-</div>

        <div class="label">SHORT MATERIAL</div><div id="shortMat">-</div>

        <div class="label">STATUS</div><div id="stage">-</div>
      </div>
    </div>

    <!-- âœ… MOVED: buttons after details at bottom of app -->
    <button class="btn" id="btnCapture">CAPTURE</button>
    <button class="btn" id="btnSubmit" style="display:none;">SUBMIT</button>
    <button class="btn" id="btnReset" style="display:none;">RESET</button>

    <script>
      window.onerror = function (msg, src, line, col, err) {
        const s = "JS ERROR: " + msg + "\n" + (src||"") + ":" + line + ":" + col;
        try { document.getElementById("status").textContent = s; } catch(e) {}
        return false;
      };
    </script>

    <script>
      // âœ… FIX: _ms_ must exist before any catch uses it
      function _ms_(t0){ return Math.round((performance.now() - t0)); }

      let uiState = "idle";
      let stream = null;

      // âœ… ADDED: holds captured OCR result until SUBMIT is clicked
      let pendingCapture = null; // { memberId, itemName, weight, dataUrl, ocrMemberName, ocrItemName }
// ===============================
// OFFLINE QUEUE (IndexedDB)
// ===============================
const OFFLINE_DB = "anymech_offline_db";
const OFFLINE_STORE = "queue";

function idbOpen(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(OFFLINE_DB, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(OFFLINE_STORE)) {
        db.createObjectStore(OFFLINE_STORE, { keyPath: "id" });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function offlineEnqueue(item){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OFFLINE_STORE, "readwrite");
    tx.objectStore(OFFLINE_STORE).put(item);
    tx.oncomplete = () => { db.close(); resolve(true); };
    tx.onerror = () => { db.close(); reject(tx.error); };
  });
}

async function offlineList(){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OFFLINE_STORE, "readonly");
    const req = tx.objectStore(OFFLINE_STORE).getAll();
    req.onsuccess = () => { const out = req.result || []; db.close(); resolve(out); };
    req.onerror = () => { db.close(); reject(req.error); };
  });
}

async function offlineRemove(id){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OFFLINE_STORE, "readwrite");
    tx.objectStore(OFFLINE_STORE).delete(id);
    tx.oncomplete = () => { db.close(); resolve(true); };
    tx.onerror = () => { db.close(); reject(tx.error); };
  });
}

function isOnline(){
  return navigator.onLine === true;
}
      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const camWrap = document.getElementById("camWrap");
      const btnFixedWrap = document.getElementById("btnFixedWrap");
      const btnCaptureFixed = document.getElementById("btnCaptureFixed");

      // âœ… ADDED: submit & reset button ref
      const btnSubmit = document.getElementById("btnSubmit");
      const btnReset  = document.getElementById("btnReset");

      function setStatus(t){ document.getElementById("status").textContent = t; }
      function setBtn(t){ document.getElementById("btnCapture").textContent = t; btnCaptureFixed.textContent = t; }
      function setText(id, t){ document.getElementById(id).textContent = (t ?? "-"); }

      function setStageText(t, completed){
        const el = document.getElementById("stage");
        el.textContent = t ?? "-";
        el.className = completed ? "ok" : "";
      }

      function setShortMaterial(v){
        const el = document.getElementById("shortMat");
        el.className = "";
        if (v === null || v === undefined || v === "" || Number.isNaN(v)){
          el.textContent = "-";
          return;
        }
        const n = Number(v);
        el.textContent = n.toFixed(3);
        if (n < -0.200) el.className = "hlRed";
        else if (n > 0.200) el.className = "hlGreen";
      }

      function tickSound(){
        try{
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "square";
          o.frequency.value = 1200;
          g.gain.value = 0.06;
          o.connect(g); g.connect(ctx.destination);
          o.start();
          setTimeout(()=>{ o.stop(); ctx.close(); }, 90);
        }catch(e){}
      }

      function showLoggedOverlay(){
        const el = document.getElementById("overlayDone");
        if (!el) return;
        el.style.display = "flex";
        setTimeout(()=>{ el.style.display = "none"; }, 1000);
      }

      function resetDisplay(){
        setText("memberId","-");
        setText("memberName","-");
        setText("itemName","-");
        setText("outW","-");
        setText("inW","-");
        setText("readyW","-");
        setShortMaterial(null);
        setStageText("-", false);
        setText("capW","-");
      }
// âœ… IMPORTANT: paste your /exec URL here (Apps Script Web App)
const APPS_SCRIPT_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbwat95xfbtJsGqKnwlqdX_6k6BMpC_66eMVA2KL25_U90Nb7j1t-qd-ofHKQBeLZOF2/exec";

// âœ… GitHub Pages version (replaces google.script.run)
async function callServer(fnName, args){
  let payload = {};

  if (fnName === "visionExtract") {
    payload = { action: "visionExtract", imageDataUrl: args[0] };
  } else if (fnName === "captureFromOcr") {
    payload = {
      action: "captureFromOcr",
      memberId: args[0],
      itemName: args[1],
      weight: args[2],
      imageDataUrl: args[3]
    };
  } else if (fnName === "postFailTasks") {
    payload = {
      action: "postFailTasks",
      imageDataUrl: args[0],
      failMessage: args[1],
      rawText: args[2]
    };
  } else {
    payload = { action: "unknown" };
  }

  const res = await fetch(APPS_SCRIPT_WEBAPP_URL, {
    method: "POST",
    body: JSON.stringify(payload)
  });

  const text = await res.text();
  return JSON.parse(text);
}

function callServerNoWait(fnName, args){
  callServer(fnName, args).catch(err=>{
    setStatus("Background fail: " + (err && err.message ? err.message : String(err)));
  });
}
      // âœ… ADDED: button sequencing helpers (never show CAPTURE and SUBMIT together)
      function showCaptureButtons(){
        // camera ON => show fixed capture, hide normal capture
        // camera OFF => show normal capture, hide fixed capture (handled by showCameraUI)
        document.getElementById("btnCapture").style.display = (camWrap.style.display === "block") ? "none" : "block";
        btnFixedWrap.style.display = (camWrap.style.display === "block") ? "block" : "none";

        // always hide submit/reset in capture mode
        btnSubmit.style.display = "none";
        btnReset.style.display = "none";
      }

      function showSubmitButtonOnly(){
        // submit mode is always camera OFF
        btnFixedWrap.style.display = "none";
        document.getElementById("btnCapture").style.display = "none";
        btnSubmit.style.display = "block";
        btnReset.style.display = "block";
      }

      function showCameraUI(on){
        camWrap.style.display = on ? "block" : "none";
        btnFixedWrap.style.display = on ? "block" : "none";

        // âœ… keep capture button down under camera screen
        document.getElementById("btnCapture").style.display = on ? "none" : "block";

        // âœ… ADDED: enforce sequencing
        if (uiState === "await_submit") {
          // if somehow called while awaiting submit, still keep submit only
          btnFixedWrap.style.display = "none";
          document.getElementById("btnCapture").style.display = "none";
          btnSubmit.style.display = "block";
          btnReset.style.display = "block";
        } else {
          btnSubmit.style.display = "none";
          btnReset.style.display = "none";
        }
      }

      window.startLiveCamera = async function startLiveCamera(){
        // âœ… BUGFIX: show the real reason when camera permission is blocked
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          throw new Error("Camera API not available in this browser/webview.");
        }
        // Camera requires HTTPS (or localhost). Insecure context often shows "permission not allowed".
        if (!window.isSecureContext){
          throw new Error("Camera blocked: page is not HTTPS (secure). Open using https:// (or localhost).");
        }

        // Make playback more reliable on mobile
        try { video.muted = true; } catch(e) {}

        // Optional: pre-check permission status if supported (does not request permission)
        try{
          if (navigator.permissions && navigator.permissions.query){
            const st = await navigator.permissions.query({ name: "camera" });
            if (st && st.state === "denied"){
              throw new Error("Camera permission is DENIED in browser settings. Allow camera for this site and reload.");
            }
          }
        }catch(e){
          // ignore (some browsers throw for permissions query)
        }

        const preferred = {
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            aspectRatio: { ideal: 16/9 }
          },
          audio: false
        };

        try{
          stream = await navigator.mediaDevices.getUserMedia(preferred);
        }catch(e1){
          try{
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: { ideal: "environment" },
                aspectRatio: { ideal: 16/9 }
              },
              audio: false
            });
          }catch(e2){
            stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          }
        }

        video.srcObject = stream;

        // âœ… ensure metadata ready (prevents blank capture)
        await new Promise(r => {
          if (video.videoWidth && video.videoHeight) return r();
          video.onloadedmetadata = () => r();
        });

        await video.play();

        // wait 1-2 frames so the camera has an actual frame rendered (prevents black captures)
        await new Promise(r => requestAnimationFrame(r));
        await new Promise(r => requestAnimationFrame(r));

        showCameraUI(true);
      }

      window.stopLiveCamera = function stopLiveCamera(){
        try{
          if (stream){
            stream.getTracks().forEach(t => t.stop());
            stream = null;
          }
        }catch(e){}
        video.srcObject = null;
        showCameraUI(false);
      }

      function captureDataUrlFull(){
        const vw = video.videoWidth || 1920;
        const vh = video.videoHeight || 1080;

        // keep full frame (no crop)
        const sy = 0;
        const sh = vh;
        const sx = 0;
        const sw = vw;

        // output scaling (same as your logic)
        const maxW = 1280;

        // âœ… FORCE OUTPUT TO LANDSCAPE (rotate if the camera frame is portrait)
        const isPortraitFrame = vh > vw;

        // If portrait, after rotation width becomes "vh" and height becomes "vw"
        const baseW = isPortraitFrame ? vh : sw;
        const baseH = isPortraitFrame ? vw : sh;

        const scale = Math.min(1, maxW / baseW);

        const outW = Math.round(baseW * scale);
        const outH = Math.round(baseH * scale);

        canvas.width = outW;
        canvas.height = outH;

        const ctx = canvas.getContext("2d", { willReadFrequently:true });
        ctx.save();

        if (isPortraitFrame){
          ctx.translate(outW, 0);
          ctx.rotate(Math.PI / 2);
          ctx.drawImage(video, sx, sy, sw, sh, 0, 0, outH, outW);
        } else {
          ctx.drawImage(video, sx, sy, sw, sh, 0, 0, outW, outH);
        }

        ctx.restore();

        return canvas.toDataURL("image/jpeg", 0.75);
      }

      // âœ… ADDED: Reset handler (discard pending capture, start capture again, do NOT submit)
      window.resetClick = async function resetClick(){
        pendingCapture = null;
        btnSubmit.textContent = "SUBMIT";

        resetDisplay();

        setBtn("CAPTURE FRAME");
        setStatus("RESET âœ…\nStarting camera again...");
        try{
          await startLiveCamera();
          uiState = "camera_on";
          setStatus("Camera ON âœ…\nPress CAPTURE FRAME to capture image first, then OCR (Submit will be shown after OCR).");
          showCaptureButtons();
        }catch(err){
          uiState = "idle";
          setBtn("CAPTURE");
          setStatus("RESET âœ…\nCamera failed: " + (err && err.name ? (err.name + " - " + (err.message || "")) : String(err)));
          showCaptureButtons();
        }
      }

      // âœ… ADDED: Submit handler (runs server submit ONLY when SUBMIT is clicked)
      window.submitClick = async function submitClick(){
        if (uiState !== "await_submit" || !pendingCapture){
          setStatus("No captured data pending. Please CAPTURE first.");
          uiState = "idle";
          pendingCapture = null;
          setBtn("CAPTURE");
          showCaptureButtons();
          return;
        }

        const tSub0 = performance.now();
        setStatus("Submitting...");
        btnSubmit.textContent = "SUBMITTING...";

        let resp;

if (!isOnline()) {

  // ðŸ”´ OFFLINE â€” store locally
  const offlineItem = {
    id: Date.now(),
    action: "captureFromOcr",
    payload: {
      memberId: pendingCapture.memberId,
      itemName: pendingCapture.itemName,
      weight: pendingCapture.weight,
      imageDataUrl: pendingCapture.dataUrl
    }
  };

  await offlineEnqueue(offlineItem);

  setStatus("ðŸ“´ No internet.\nSaved offline.\nWill auto sync when online.");

  btnSubmit.textContent = "SUBMIT";
  uiState = "idle";
  setBtn("CAPTURE");
  showCaptureButtons();
  return;
}

try{
  resp = await callServer("captureFromOcr", [
    pendingCapture.memberId,
    pendingCapture.itemName,
    pendingCapture.weight,
    pendingCapture.dataUrl
  ]);
}catch(err){

  // ðŸ”´ NETWORK ERROR â€” store offline
  const offlineItem = {
    id: Date.now(),
    action: "captureFromOcr",
    payload: {
      memberId: pendingCapture.memberId,
      itemName: pendingCapture.itemName,
      weight: pendingCapture.weight,
      imageDataUrl: pendingCapture.dataUrl
    }
  };

  await offlineEnqueue(offlineItem);

  setStatus("âš ï¸ Network error.\nSaved offline.\nWill auto sync.");

  btnSubmit.textContent = "SUBMIT";
  uiState = "idle";
  setBtn("CAPTURE");
  showCaptureButtons();
  return;
}
      catch(err){
          const msSub = _ms_(tSub0);
          setStatus(
            "ERROR: Submit call failed\n" +
            (err && err.message ? err.message : String(err)) +
            "\n\nTIMING:\nSubmit call: " + msSub + " ms"
          );
          btnSubmit.textContent = "SUBMIT";
          return;
        }

        const msSub = _ms_(tSub0);

        if (!resp || !resp.ok){
          setStatus("ERROR: " + (resp && resp.message ? resp.message : "Unknown submit error"));
          btnSubmit.textContent = "SUBMIT";
          return;
        }

        const d = (resp && resp.data) ? resp.data : {};

        const outW = (d.outWeight !== undefined && d.outWeight !== null && String(d.outWeight).trim() !== "") ? Number(d.outWeight) : null;
        const inW  = (d.inWeight  !== undefined && d.inWeight  !== null && String(d.inWeight).trim()  !== "") ? Number(d.inWeight)  : null;
        const rdW  = (d.readyWeight !== undefined && d.readyWeight !== null && String(d.readyWeight).trim() !== "") ? Number(d.readyWeight) : null;

        setText("outW",   (outW !== null && !Number.isNaN(outW)) ? String(outW) : "-");
        setText("inW",    (inW  !== null && !Number.isNaN(inW))  ? String(inW)  : "-");
        setText("readyW", (rdW  !== null && !Number.isNaN(rdW))  ? String(rdW)  : "-");

        if (resp.stage === "OUT" || resp.stage === "IN" || resp.stage === "READY") tickSound();

        if (outW !== null && inW !== null && !Number.isNaN(outW) && !Number.isNaN(inW)) setShortMaterial(inW - outW);
        else setShortMaterial(null);

        setText("memberId",   d.memberId || pendingCapture.memberId || "-");
        setText("memberName", d.memberName || pendingCapture.ocrMemberName || "-");
        setText("itemName",   d.itemName || pendingCapture.itemName || "-");

        setText("capW","-");

        let st = d.statusText || resp.stage || "-";
        const completed = !!d.completed;

        if (resp.stage === "OUT") {
          st = "OUT âœ…";
          showLoggedOverlay();
        } else if (resp.stage === "READY" || completed === true) {
          st = "COMPLETED âœ…";
          showLoggedOverlay();
        } else if (resp.stage === "IN") {
          st = "IN âœ…";
        }

        setStageText(st, completed || resp.stage === "READY");

        pendingCapture = null;

        setStatus(
          "SUCCESS âœ… " + resp.message + " (" + st + ")" +
          "\n\nTIMING:\nSubmit call: " + msSub + " ms"
        );

        if (resp.stage === "IN") {
          uiState = "idle";
          btnSubmit.textContent = "SUBMIT";
          setBtn("CAPTURE READY");
          setStatus("IN saved âœ…\nNow capture READY WEIGHT (click CAPTURE READY).");
          try{
            await startLiveCamera();
            uiState = "camera_on";
            showCaptureButtons();
          }catch(err){
            uiState = "idle";
            setBtn("CAPTURE");
            showCaptureButtons();
            setStatus("IN saved âœ…\nCamera failed for READY: " + (err && err.message ? err.message : String(err)));
          }
          return;
        }

        uiState = "idle";
        btnSubmit.textContent = "SUBMIT";
        setBtn("CAPTURE");
        showCaptureButtons();
      }

      window.captureClick = async function captureClick(){
        if (uiState === "idle"){
          pendingCapture = null;
          btnSubmit.textContent = "SUBMIT";
          btnSubmit.style.display = "none";
          btnReset.style.display = "none";

          resetDisplay();
          setBtn("CAPTURE FRAME");
          setStatus("Starting live camera...");
          try{
            await startLiveCamera();
            uiState = "camera_on";
            setStatus("Camera ON âœ…\nPress CAPTURE FRAME to capture image first, then OCR (Submit will be shown after OCR).");
            showCaptureButtons();
          }catch(err){
            uiState = "idle";
            setBtn("CAPTURE");
            setStatus("Camera failed: " + (err && err.name ? (err.name + " - " + (err.message || "")) : String(err)));
            showCaptureButtons();
          }
          return;
        }

        if (uiState === "camera_on"){
          setBtn("PROCESSING...");
          setStatus("Capturing image (freezing frame)...");
          const dataUrl = captureDataUrlFull();

          stopLiveCamera();

          const tAll0 = performance.now();

          setStatus("Image captured âœ…\nRunning OCR...");
          const tOcr0 = performance.now();
          let r;
          try{
            r = await callServer("visionExtract", [dataUrl]);
          }catch(err){
            const msOcr = _ms_(tOcr0);

            setStatus(
              "ERROR: OCR call failed\n" +
              (err && err.message ? err.message : String(err)) +
              "\n\nTIMING:\nOCR call: " + msOcr + " ms"
            );

            setBtn("CAPTURE");
            uiState = "idle";
            showCaptureButtons();
            return;
          }

          const msOcr = _ms_(tOcr0);

          if (!r || !r.ok){
            const msAll = _ms_(tAll0);

            callServerNoWait("postFailTasks", [
              dataUrl,
              (r && r.message) ? r.message : "OCR failed",
              (r && r.rawText) ? r.rawText : ""
            ]);

            setStatus(
              "ERROR: OCR failed.\n" +
              (r && r.message ? r.message : "Unknown OCR error") +
              "\n\nERROR DETAIL:\n" + (r && r.error ? r.error : "") +
              "\n\nRAW:\n" + (r && r.rawText ? r.rawText : "") +
              "\n\nTIMING:\nOCR call: " + msOcr + " ms\nTOTAL: " + msAll + " ms"
            );

            setBtn("CAPTURE");
            uiState = "idle";
            showCaptureButtons();
            return;
          }

          setText("memberId", r.memberId || "-");
          setText("memberName", r.memberName || "-");
          setText("itemName", r.itemName || "-");
          setText("capW", (r.weight !== undefined && r.weight !== null) ? String(r.weight) : "-");

          pendingCapture = {
            memberId: r.memberId,
            itemName: r.itemName,
            weight: r.weight,
            dataUrl: dataUrl,
            ocrMemberName: r.memberName || "",
            ocrItemName: r.itemName || ""
          };

          uiState = "await_submit";
          setBtn("CAPTURE");
          setStatus(
            "OCR DONE âœ…\n" +
            "Press SUBMIT to upload & sync to Google Sheet.\n\n" +
            "TIMING:\nOCR call: " + msOcr + " ms"
          );

          showSubmitButtonOnly();
          return;
        }
      }

      resetDisplay();
      setBtn("CAPTURE");
      setStatus("Press CAPTURE to start live camera.");

      document.getElementById("btnCapture").addEventListener("click", captureClick);
      btnCaptureFixed.addEventListener("click", captureClick);

      btnSubmit.addEventListener("click", submitClick);
      btnReset.addEventListener("click", resetClick);

      showCaptureButtons();
        // ===============================
// AUTO SYNC WHEN ONLINE
// ===============================
async function syncOfflineQueue(){
// Trigger sync when connection returns
window.addEventListener("online", () => {
  syncOfflineQueue();
});

// Try sync every 30 seconds
setInterval(syncOfflineQueue, 30000);
  if (!isOnline()) return;

  const items = await offlineList();
  if (!items.length) return;

  setStatus("ðŸ”„ Syncing offline data...");

  for (const item of items){

    try{
      await callServer("captureFromOcr", [
        item.payload.memberId,
        item.payload.itemName,
        item.payload.weight,
        item.payload.imageDataUrl
      ]);

      await offlineRemove(item.id);

    }catch(e){
      console.log("Sync failed, will retry later.");
      return; // stop sync if still failing
    }
  }

  setStatus("âœ… Offline data synced successfully.");
}
    </script>
  </div>

  <div class="overlayDone" id="overlayDone">
    <div class="overlayCard">
      <div class="overlayTick">âœ…</div>
      <div class="overlayText">LOGGED COMPLETED</div>
    </div>
  </div>
</body>
</html>
