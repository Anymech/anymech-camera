<script>
function _ms_(t0){ return Math.round((performance.now() - t0)); }

let uiState = "idle";
let stream = null;
let pendingCapture = null;

// ===============================
// OFFLINE QUEUE (IndexedDB)
// ===============================
const OFFLINE_DB = "anymech_offline_db";
const OFFLINE_STORE = "queue";

function idbOpen(){
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(OFFLINE_DB, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(OFFLINE_STORE)) {
        db.createObjectStore(OFFLINE_STORE, { keyPath: "id" });
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function offlineEnqueue(item){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OFFLINE_STORE, "readwrite");
    tx.objectStore(OFFLINE_STORE).put(item);
    tx.oncomplete = () => { db.close(); resolve(true); };
    tx.onerror = () => { db.close(); reject(tx.error); };
  });
}

async function offlineList(){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OFFLINE_STORE, "readonly");
    const req = tx.objectStore(OFFLINE_STORE).getAll();
    req.onsuccess = () => { const out = req.result || []; db.close(); resolve(out); };
    req.onerror = () => { db.close(); reject(req.error); };
  });
}

async function offlineRemove(id){
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(OFFLINE_STORE, "readwrite");
    tx.objectStore(OFFLINE_STORE).delete(id);
    tx.oncomplete = () => { db.close(); resolve(true); };
    tx.onerror = () => { db.close(); reject(tx.error); };
  });
}

function isOnline(){
  return navigator.onLine === true;
}

// ===============================
// SERVER CALL (FIXED)
// ===============================
const APPS_SCRIPT_WEBAPP_URL = "https://script.google.com/macros/s/AKfycbwJr73l_9BJfiRAEpIz-x90zhOX78ny4kH53X_RifEqFN7WFcgnnAUpwbeMisMVvtFQcA/exec";

async function callServer(fnName, args){
  let payload = {};

  if (fnName === "visionExtract") {
    payload = { action: "visionExtract", imageDataUrl: args[0] };
  } else if (fnName === "captureFromOcr") {
    payload = {
      action: "captureFromOcr",
      memberId: args[0],
      itemName: args[1],
      weight: args[2],
      imageDataUrl: args[3]
    };
  } else if (fnName === "postFailTasks") {
    payload = {
      action: "postFailTasks",
      imageDataUrl: args[0],
      failMessage: args[1],
      rawText: args[2]
    };
  }

  const res = await fetch(APPS_SCRIPT_WEBAPP_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },   // ‚úÖ FIXED
    body: JSON.stringify(payload)
  });

  const text = await res.text();
  return JSON.parse(text);
}

function callServerNoWait(fnName, args){
  callServer(fnName, args).catch(err=>{
    console.log("Background fail:", err);
  });
}

// ===============================
// SUBMIT CLICK (FIXED)
// ===============================
window.submitClick = async function submitClick(){

  if (uiState !== "await_submit" || !pendingCapture){
    setStatus("No captured data pending. Please CAPTURE first.");
    uiState = "idle";
    setBtn("CAPTURE");
    showCaptureButtons();
    return;
  }

  btnSubmit.textContent = "SUBMITTING...";

  // OFFLINE
  if (!isOnline()) {
    await offlineEnqueue({
      id: Date.now(),
      payload: {
        memberId: pendingCapture.memberId,
        itemName: pendingCapture.itemName,
        weight: pendingCapture.weight,
        imageDataUrl: pendingCapture.dataUrl
      }
    });

    setStatus("üì¥ Saved offline. Will auto sync when online.");
    btnSubmit.textContent = "SUBMIT";
    uiState = "idle";
    setBtn("CAPTURE");
    showCaptureButtons();
    return;
  }

  let resp;

  try{
    resp = await callServer("captureFromOcr", [
      pendingCapture.memberId,
      pendingCapture.itemName,
      pendingCapture.weight,
      pendingCapture.dataUrl
    ]);
  }catch(err){

    await offlineEnqueue({
      id: Date.now(),
      payload: {
        memberId: pendingCapture.memberId,
        itemName: pendingCapture.itemName,
        weight: pendingCapture.weight,
        imageDataUrl: pendingCapture.dataUrl
      }
    });

    setStatus("‚ö†Ô∏è Network error. Saved offline.");
    btnSubmit.textContent = "SUBMIT";
    uiState = "idle";
    setBtn("CAPTURE");
    showCaptureButtons();
    return;
  }

  if (!resp || !resp.ok){
    setStatus("ERROR: " + (resp && resp.message ? resp.message : "Unknown error"));
    btnSubmit.textContent = "SUBMIT";
    return;
  }

  setStatus("SUCCESS ‚úÖ " + resp.message);
  btnSubmit.textContent = "SUBMIT";
  uiState = "idle";
  setBtn("CAPTURE");
  showCaptureButtons();
};

// ===============================
// AUTO SYNC (FIXED)
// ===============================
async function syncOfflineQueue(){

  if (!isOnline()) return;

  const items = await offlineList();
  if (!items.length) return;

  setStatus("üîÑ Syncing offline data...");

  for (const item of items){
    try{
      await callServer("captureFromOcr", [
        item.payload.memberId,
        item.payload.itemName,
        item.payload.weight,
        item.payload.imageDataUrl
      ]);

      await offlineRemove(item.id);

    }catch(e){
      console.log("Sync failed, retry later.");
      return;
    }
  }

  setStatus("‚úÖ Offline data synced.");
}

// listeners OUTSIDE function (FIXED)
window.addEventListener("online", syncOfflineQueue);
setInterval(syncOfflineQueue, 30000);

</script>
